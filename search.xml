<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>功能测试</title>
      <link href="/2023/11/18/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/11/18/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h1><h2 id="按照是否覆盖源代码"><a href="#按照是否覆盖源代码" class="headerlink" title="按照是否覆盖源代码"></a>按照是否覆盖源代码</h2><ul><li><p>黑盒测试：关注输入输出</p></li><li><p>白盒测试：关注代码内部实现逻辑</p></li><li><p>灰盒测试：关注输入输出以及代码内部实现逻辑</p></li></ul><h2 id="按照测试阶段"><a href="#按照测试阶段" class="headerlink" title="按照测试阶段"></a>按照测试阶段</h2><ul><li>单元测试：在底层对一个独立单独的模块展开测试，是对软件中最小可测单元进行检查和验证</li><li>集成测试：在单元测试的基础上，将所有模块进行有序的，递增的测试，重点测试不同模块的接口</li><li>系统测试：将整个系统看成一个整体进行测试，分为软件层面和硬件层面，依据软件需求说明书</li><li>验收测试：检验软件是否符合用户需求的测试<ul><li>类型：<ul><li>α测试：内测版本，bug多</li><li>β测试：公测版本</li><li>γ测试：候选发布版本</li></ul></li></ul></li></ul><h2 id="按照是否运行"><a href="#按照是否运行" class="headerlink" title="按照是否运行"></a>按照是否运行</h2><ul><li>静态测试：指不实际运行被测软件，而只是静态检查界面或文档中可能存在的错误 </li><li>动态测试：实际运行被测软件</li></ul><h2 id="按照是否自动化"><a href="#按照是否自动化" class="headerlink" title="按照是否自动化"></a>按照是否自动化</h2><ul><li>手动测试</li><li>自动化测试：利用代码或者工具帮助测试人员测试的过程</li></ul><h1 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h1><h2 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h2><ul><li>组成：需求分析&#x3D;&#x3D;》概要设计&#x3D;&#x3D;》详细设计&#x3D;&#x3D;》编码&#x3D;&#x3D;》单元测试&#x3D;&#x3D;》集成测试&#x3D;&#x3D;》系统测试&#x3D;&#x3D;》验收测试</li><li>优点：只需要关注当前阶段，文档驱动，线性模型</li><li>缺点：不响应需求的变化，不灵活</li></ul><h2 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h2><ul><li>绘制<ul><li>开发V：需求分析&#x3D;&#x3D;》概要设计&#x3D;&#x3D;》详细设计&#x3D;&#x3D;》编码&#x3D;&#x3D;》集成&#x3D;&#x3D;》实施&#x3D;&#x3D;》交付</li><li>测试V：验收测试设计&#x3D;&#x3D;》系统测试设计&#x3D;&#x3D;》集成测试设计&#x3D;&#x3D;》单元测试设计&#x3D;&#x3D;》单元测试&#x3D;&#x3D;》集成测试&#x3D;&#x3D;》系统测试&#x3D;&#x3D;》验收测试</li></ul></li><li>优点：<ul><li>测试贯穿软件开发的全生命周期</li><li>早参与，早发现，早解决</li></ul></li><li>缺点：<ul><li>技术和管理要求比较高</li></ul></li></ul><h1 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h1><ul><li>功能：关注业务功能使用</li><li>可靠性：容错性能，纠错能力</li><li>易用性：易读易懂</li><li>效率：时间性能要求</li><li>可维护性：软件运维人员去维护公司现有项目</li><li>可移植性：在不同软件硬件平台都能正常工作</li></ul><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>一个为了特定目的（验证产品功能实现是否满足用户需求）而设计的包含【测试输入，执行条件，预期结果】的文档。文档的形式：Excel，Xmind等</p><h2 id="软件测试用例的作用"><a href="#软件测试用例的作用" class="headerlink" title="软件测试用例的作用"></a>软件测试用例的作用</h2><ul><li>便于理清测试思路，确保需覆盖测试的功能点无遗漏</li><li>便于测试工作量的评估</li><li>便于提前准备测试数据</li><li>便于把控测试工作进度</li><li>便于回归测试</li><li>便于测试工作的组织，提高测试效率，降低测试交接成本</li></ul><h2 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h2><h3 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h3><ul><li>概念： 通过科学的方法找到具有共同特性的测试输入的子集，能够从穷举测试中解放（大大减少了测试数量，从而提升测试效率）</li><li>分类：<ul><li>有效等价类：满足需求</li><li>无效等价类：不满足需求</li></ul></li><li>设计测试用例的步骤<ul><li>需求分析</li><li>划分等价类<ul><li>有效的</li><li>无效的<ul><li>规则（需求本身）</li><li>长度</li><li>类型</li><li>是否为空</li><li>是否重复</li></ul></li></ul></li><li>设计用例</li></ul></li><li>典型应用场景<ul><li>输入框</li></ul></li></ul><h3 id="边界值"><a href="#边界值" class="headerlink" title="边界值"></a>边界值</h3><ul><li>作用：对等价类的补充，统计表明程序最容易出错的地方就是在边界附近</li><li>边界值<ul><li>上点：边界之上的点</li><li>内点：边界之内的点</li><li>离点：离边界最近的左右两点</li></ul></li><li>设计测试用例步骤<ul><li>需求分析</li><li>划分等价类</li><li>确定边界<ul><li>上点</li><li>内点</li><li>离点</li></ul></li><li>设计测试用例</li></ul></li><li>典型应用场景<ul><li>存在边界 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 大于 小于 等于</li></ul></li></ul><h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><ul><li>存在多个输入条件，多个输出结果，输入与输出之间有组合关系，输入与输出有制约关系</li><li>判定表组成：<ul><li>条件桩：所有输入条件</li><li>动作桩：所有的可能的输出结果</li><li>条件项：单个条件的取值范围，一般都是有效等价类和无效等价类</li><li>动作项：基于每一种条件的组合得到确认的结果</li></ul></li><li>设计测试用例的步骤<ul><li>明确条件桩（找到所有的输入条件）</li><li>明确动作桩（找到所有的输出结果）</li><li>对条件桩进行全组合</li><li>明确每个组合对于的动作桩（基于每一种条件的组合情况确定本组合下的输出结果）</li><li>设计测试用例，每一行数据对于一条测试用例</li></ul></li><li>典型应用场景：<ul><li>多条件组合情况</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 功能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/11/02/Redis/"/>
      <url>/2023/11/02/Redis/</url>
      
        <content type="html"><![CDATA[<p>Redis是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。和Memcached类似。redis支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。</p><h2 id="单线程Redis为什么这么快"><a href="#单线程Redis为什么这么快" class="headerlink" title="单线程Redis为什么这么快"></a>单线程Redis为什么这么快</h2><ul><li>基于内存操作</li><li>使用了I&#x2F;O多路复用模式</li><li>单线程避免了不必要的上下文切换和竞争条件</li></ul><h2 id="为什么要使用缓存"><a href="#为什么要使用缓存" class="headerlink" title="为什么要使用缓存"></a>为什么要使用缓存</h2><ul><li>Redis是基于内存存储计算，性能速读远超mysql等数据库，计算速度很快，所以在使用的时候数据响应很快，</li><li>Redis支持多种多样的数据结构，如字符串、tree、ztree、map、等，这些丰富的数据结构，可以满足我们在开发工作大部分常见数据结构，进行存储。</li><li>Redis丰富的api支持，让我们在使用的时候，常见的查询存储都能够很方便的使用，支持自定的查询的api等等</li><li>Redis的生态比较成熟，很多家大型公司都在使用，很多相关的知识扩展以及分析</li><li>Redis分布式集群化扩展性极高，而且稳定，能够支撑大量的数据吞吐，只要硬件支持。</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透： 缓存中查不到，数据库中也查不到。</p><p>解决方法：</p><ul><li>对参数进行合法性校验。</li><li>将数据库中没有查到结果的数据也写入到缓存。这时要注意为了防止Redis被无用的Key占满，这一类缓存的有效期要设置得短一点。</li><li>引入布隆过滤器，在访问Redis之前判断数据是否存在。 要注意布隆过滤器存在一定的误判率，并且，布隆过滤器只能加数据不能减数据。</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿：缓存中没有，数据库中有。一般是出现在存数数据初始化以及key过期了的情况。他的问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成很大的压力。</p><p>解决方法：</p><ul><li>设置这个热点缓存永不过期。这时要注意在value当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p> 缓存大面积过期，导致请求都被转发到DB。</p><p>解决办法：</p><ul><li>把缓存的时效时间分散开。例如，在原有的统一失效时间基础上，增加一个随机值。</li><li>对热点数据设置永不过期。</li></ul><h2 id="删除策略和淘汰机制"><a href="#删除策略和淘汰机制" class="headerlink" title="删除策略和淘汰机制"></a>删除策略和淘汰机制</h2><h3 id="删除策略："><a href="#删除策略：" class="headerlink" title="删除策略："></a>删除策略：</h3><ul><li><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间就扫描一定数据的设置了过期时间的key，并清除其中已过期的keys。如果有多于25%的key过期，重复上述步骤。</p></li><li><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>访问key时判断是否过期，过期才删除。也就是说如果这个key过期后一直没有访问它，那么它就一直在不会被删除。</p></li></ul><h3 id="淘汰机制："><a href="#淘汰机制：" class="headerlink" title="淘汰机制："></a>淘汰机制：</h3><ul><li>noeviction（默认策略）： 不会删除任何数据，拒绝所有写入操作并返回客户端错误消息（error）OOM command not allowed when used memory，此时 Redis 只响应删和读操作；</li><li>allkeys-lru： 从所有 key 中使用 LRU 算法进行淘汰（LRU 算法：最近最少使用算法）；</li><li>allkeys-lfu： 从所有 key 中使用 LFU 算法进行淘汰（LFU 算法：最不常用算法，根据使用频率计算，4.0 版本新增）；</li><li>volatile-lru： 从设置了过期时间的 key 中使用 LRU 算法进行淘汰；</li><li>volatile-lfu： 从设置了过期时间的 key 中使用 LFU 算法进行淘汰；</li><li>allkeys-random： 从所有 key 中随机淘汰数据；</li><li>volatile-random： 从设置了过期时间的 key 中随机淘汰数据；</li><li>volatile-ttl： 在设置了过期时间的key中，淘汰过期时间剩余最短的。</li></ul><h2 id="Redis中的数据类型"><a href="#Redis中的数据类型" class="headerlink" title="Redis中的数据类型"></a>Redis中的数据类型</h2><ul><li>String：以字符串形式存储数据，经常用于纪录用户的访问次数，文章访问量等。</li><li>hash：以对象形式存储数据，比较方便的就是操作其中的某个字段。例如存储登录用户登录状态</li><li>list：以列表形式存储数据，可记录添加顺序，允许元素重复，通常应用于发布与订阅，慢查询</li><li>set：以集合形式存储数据，不记录添加顺序，元素不可重复，也不能保证存储顺序</li><li>zset：排序集合，可对数据基于某个权重进行排序。可做排行榜</li></ul><h2 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h2><p>Redis持久化是把内存中的数据同步到硬盘文件中，当Redis重启后再将硬盘文件内存重新加载到内存以实现数据恢复的目的。具体持久化方式分为RDB和AOF方式。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><strong>优缺点</strong>：</p><ul><li><p>优点：AOF相对RDB更加安全，一般不会有数据的丢失或者很少，官方推荐同时开启AOF和RDB。</p></li><li><p>缺点：AOF持久化的速度，相对于RDB较慢，存储的是一个文本文件，到了后期文件会比较大，传输困难。</p></li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程就是有一个fork子进程，先将数据集写入到临时文件中，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><strong>RDB的优缺点：</strong></p><ul><li><p>优点：RDB持久化文件，速度比较快，而且存储的是一个二进制文件，传输起来很方便。</p></li><li><p>缺点：RDB无法保证数据的绝对安全，有时候就是1s也会有很大的数据丢失。</p></li></ul><h3 id="Redis的混合持久化"><a href="#Redis的混合持久化" class="headerlink" title="Redis的混合持久化"></a>Redis的混合持久化</h3><ul><li>混合持久化只发生与AOF重写过程。使用了混合持久化，重写后的新AOF文件前半段就是RDB格式的全量数据，后半段是AOF格式的增量数据</li><li>使用aof-use-rdb-preamble yes即可打开混合持久化，开启混合持久化后，fork出的子进程先将当前全量数据以RDB方式写入到新的AOF文件中，在将AOF重写到新的文件中，雪茹完成后通知主进程将新的RDB格式和AOF格式的AOF文件替换旧的AOF文件</li><li>优点：结合RDB和AOF的优点，更快的重写与恢复</li><li>缺点：AOF文件里面的RDB部分不再是AOF格式，可读性差</li></ul><h2 id="如何保证数据库与缓存数据一致性？"><a href="#如何保证数据库与缓存数据一致性？" class="headerlink" title="如何保证数据库与缓存数据一致性？"></a>如何保证数据库与缓存数据一致性？</h2><ul><li>旁路缓存模式（Cache-Aside-Pattern）：读取缓存，读取数据库和更新缓存的操作都是在应用系统中完成，也是业务系统最常用的缓存策略</li><li>解决方案<ul><li>缓存延迟双删<ul><li>先删除缓存，在更新数据库，确保数据库事务提交成功，然后休眠一段时间，在删除缓存</li><li>若删除缓存失败，则把需要删除失败的key存入消息队列中，采用异步的方式来进行删除，如果删除失败次数超过最大次数，则需要人工介入</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring生态圈</title>
      <link href="/2023/11/01/Spring%E7%94%9F%E6%80%81%E5%9C%88/"/>
      <url>/2023/11/01/Spring%E7%94%9F%E6%80%81%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring生态圈"><a href="#Spring生态圈" class="headerlink" title="Spring生态圈"></a>Spring生态圈</h1><p>spring 生态圈是指以 Spring 框架为核心的一系列相关技术和框架，它包括了很多不同的组件和模块，可以用来构建各种类型的应用程序。Spring 生态圈提供了丰富的功能和特性，其中一些最流行的组件如下：</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新<a href="https://baike.baidu.com/item/Spring/85061?fromModule=lemma_inlink">Spring</a>应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置</p><h3 id="Spring-Boot优点"><a href="#Spring-Boot优点" class="headerlink" title="Spring Boot优点"></a>Spring Boot优点</h3><ul><li>自动配置</li><li>起步依赖（简化依赖配置）</li><li>辅助功能（内置Tomcat服务器）</li></ul><h3 id="Spring-Boot的三种配置文件格式"><a href="#Spring-Boot的三种配置文件格式" class="headerlink" title="Spring Boot的三种配置文件格式"></a>Spring Boot的三种配置文件格式</h3><ul><li><h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4></li><li><h4 id="application-yml（常用）"><a href="#application-yml（常用）" class="headerlink" title="application.yml（常用）"></a>application.yml（常用）</h4></li><li><h4 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application. yaml"></a>application. yaml</h4></li></ul><p>SpringBoot 配置文件加载顺序application.properties &gt; application.yml &gt; application.yaml</p><h3 id="配置文件中读取数据"><a href="#配置文件中读取数据" class="headerlink" title="配置文件中读取数据"></a>配置文件中读取数据</h3><ul><li>采用@Value注解读取yml中的key</li><li>采用Evironment 环境变量进行获取</li><li>@ConfigurationProperties读取配置文件</li></ul><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li><h3 id="Service"><a href="#Service" class="headerlink" title="@Service:"></a>@Service:</h3><p>用于标注业务层组件；</p></li><li><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController:"></a>@RestController:</h3><p>用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody；</p></li><li><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller:"></a>@Controller:</h3><p>用于标注是控制层组件，需要返回页面时请用@Controller而不是@RestController；</p></li><li><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody:"></a>@RequestBody:</h3><p>参数前加上这个注解之后，认为该参数必填。表示接受json字符串转为对象 List等；</p></li><li><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration:"></a>@Configuration:</h3><p>指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上；</p></li><li><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean:"></a>@Bean:</h3><p>产生一个bean,并交给spring管理；</p></li><li><h3 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired:"></a>@AutoWired:</h3><p>byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作；</p></li></ul><h2 id="Spring-Cloud（Alibaba）"><a href="#Spring-Cloud（Alibaba）" class="headerlink" title="Spring Cloud（Alibaba）"></a>Spring Cloud（Alibaba）</h2><p>在这里使用的是Spring Cloud Alibaba。<code>SpringCloud Alibaba</code> 是微服务开发的一站式解决方案。该项目具备开发分布式应用和服务所需的组件，以至于开发者能够更容易使用 <code>SpringCloud</code> 的编程模型开发分布式应用。Spring Cloud有五大组件。</p><p>使用Spring Cloud的好处：</p><ul><li>容灾性好：代码耦合度低，发生事故不会影响其他模块的使用</li><li>项目管理：并行开发，不用过多关注其他人开发</li></ul><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos是一个用于服务发现、动态配置管理和服务元数据的服务。它可以作为注册中心，帮助微服务实例进行注册和发现，从而实现服务之间的通信。此外，Nacos还提供了动态配置管理，允许开发者动态调整应用程序的配置信息，而无需重新部署。</p><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel是一款强大的流量控制和熔断降级组件。它可以帮助开发者在微服务架构中对流量进行实时监控和管理，确保服务的稳定性和可靠性。Sentinel还支持熔断降级策略，可以在出现故障或异常情况下保护系统免受影响。</p><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>Seata是一款开源的分布式事务解决方案，用于在微服务架构中保障跨多个服务的事务一致性。它提供了全局事务管理和本地事务协调功能，确保在分布式环境下的数据一致性和可靠性。</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p> Dubbo是一款高性能的Java RPC框架，用于实现微服务之间的远程调用。它提供了服务治理、负载均衡、容错机制等功能，使得微服务之间的通信更加便捷和高效。Spring Cloud Alibaba集成了Dubbo作为其中的一个通信组件，为微服务架构提供了灵活的通信方式。</p><h3 id="RocketMQ（RabbitMQ）"><a href="#RocketMQ（RabbitMQ）" class="headerlink" title="RocketMQ（RabbitMQ）"></a>RocketMQ（RabbitMQ）</h3><p>RocketMQ是一种分布式消息中间件，用于实现高吞吐量、高可用性的消息传递。它支持发布-订阅和点对点模式，适用于异步消息通信和解耦。RocketMQ在微服务架构中可以作为通信的中介，帮助不同微服务之间进行可靠的消息传递。</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p><em>Spring Security</em>是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架，是一个功能强大且高度可定制的身份验证和访问控制框架。</p><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><ul><li>Spring Security的核心原理是拦截器（Filter）。Spring Security会在Web应用程序的过滤器链中添加一组自定义的过滤器，这些过滤器可以实现身份验证和授权功能。当用户请求资源时，Spring Security会拦截请求，并使用配置的身份验证机制来验证用户身份。如果身份验证成功，Spring Security会授权用户访问所请求的资源。</li></ul><h3 id="两大核心功能"><a href="#两大核心功能" class="headerlink" title="两大核心功能"></a>两大核心功能</h3><ul><li><strong>用户认证</strong>：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。</li><li><strong>用户授权</strong>：验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，有的用户既能读取，又能修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</li></ul><h3 id="Spring-Security的工作原理"><a href="#Spring-Security的工作原理" class="headerlink" title="Spring Security的工作原理"></a>Spring Security的工作原理</h3><ul><li>用户请求Web应用程序的受保护资源。</li><li>Spring Security拦截请求，并尝试获取用户的身份验证信息。</li><li>如果用户没有经过身份验证，Spring Security将向用户显示一个登录页面，并要求用户提供有效的凭据（用户名和密码）。</li><li>一旦用户提供了有效的凭据，Spring Security将验证这些凭据，并创建一个已认证的安全上下文（SecurityContext）对象。</li><li>在接下来的请求中，Spring Security将使用已经认证的安全上下文对象来判断用户是否有权访问受保护的资源。</li><li>如果用户有权访问资源，Spring Security将允许用户访问资源，否则将返回一个错误信息。</li></ul><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>SpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分。简化开发，减少出错，方便组内开发人员之间的配合。</p><h3 id="Spring-MVC主要组件"><a href="#Spring-MVC主要组件" class="headerlink" title="Spring MVC主要组件"></a>Spring MVC主要组件</h3><ul><li>前端控制器（DispatcherServlet）：接收请求、响应结果，相当于转发器，有了DispatcherServlet就减少了其他组件之间的耦合度。</li><li>处理器映射器（HandlerMapping）：根据请求的URL来查找Handler</li><li>处理器适配器（HandlerAdapter）：负责执行Handler</li><li>处理器（Handler）：处理业务逻辑的Java类</li><li>视图解析器（ViewResolver）：进行视图的解析，根据视图逻辑名将ModelAndView解析成真正的视图。</li><li>视图（View）：View是一个接口，他的实现类支持不同的视图类型，如jsp，freemarker等等</li></ul><h3 id="MVC的设计理念"><a href="#MVC的设计理念" class="headerlink" title="MVC的设计理念"></a>MVC的设计理念</h3><p>MVC是一种使用MVC（Model View Controller）设计创建Wed运行程序的模式</p><ul><li>Model（模型）：表示应用程序的核心，处理应用程序数据逻辑的部分</li></ul><ul><li><p>View（视图）：显示数据</p></li><li><p>Controller（控制器）：处理输入与交互流程</p></li></ul><ul><li>springmvc的工作流程：<ul><li>当客户端发送请求时，请求会被 DispatcherServlet 拦截。</li><li>DispatcherServlet 会根据请求的 URL 找到对应的 Controller。</li><li>Controller 接收到请求后，会根据业务逻辑处理请求，并返回 ModelAndView 对象。ModelAndView 对象包含了视图名称和模型数据。</li><li>DispatcherServlet 会根据视图名称找到对应的视图解析器，并将模型数据传递给视图。</li><li>视图解析器将模型数据渲染到视图上，并将视图返回给客户端。</li></ul></li></ul><p>Spring 生态圈中还有很多其他组件，这些组件都是通过轻量级、松耦合、可重用的方式来构建应用程序。通过使用 Spring 生态圈，开发人员可以更加快速、简单地构建高质量的应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring生态圈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
